# ペアテーブル ptbl を算出し，ファイルに書き出す
# 実行例： python save_tbl.py 0 10

import os
import sys
import time
import numpy as np
import random
import math
import matplotlib.pyplot as plt
import scipy.stats as sps
import scipy.cluster
from scipy.stats import f

import torch
import torch.nn as nn
from torch.autograd import Function
import pynvml
import sow_cpp
#from pdb import set_trace as db

def seed_everything(seed=0):
    """Fix all random seeds"""
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    torch.backends.cudnn.benchmark = False
    torch.backends.cudnn.deterministic = True

def mktbl(M, device):
    N = 2 ** M
    tbl = torch.empty((N-1, int(N/2), 2), dtype=torch.int, device=device, requires_grad=False)
    tbl4 = torch.tensor([[[0, 1], [2, 3]], [[0, 2], [1, 3]], [[0, 3], [1, 2]]],
                        dtype=torch.int, device=device, requires_grad=False)
    for i in range(3):
        for j in range(2):
            tbl[i][j][0] = tbl4[i][j][0]
            tbl[i][j][1] = tbl4[i][j][1]
    for k in range(M-2):
        n = 2 ** (2+k)
        for i in range(n-1):
            for j in range(int(n/2)):
                tbl[i][int(n/2)+j][0] = tbl[i][j][0] + n
                tbl[i][int(n/2)+j][1] = tbl[i][j][1] + n
        for i in range(n-1, 2*n-1):
            for j in range(n):
                tbl[i][j][0] = j
                tbl[i][j][1] = (i-n+1+j) % n + n
    # reverse
    tmp = torch.empty((int(N/2), 2), dtype=torch.int, device=device, requires_grad=False)
    for i in range(int(N/2)-1):
        tmp = torch.clone(tbl[i,:,:]).detach()
        tbl[i,:,:] = tbl[N-2-i,:,:]
        tbl[N-2-i,:,:] = tmp
    return tbl.view(-1)

def print_ptbl(tbl):
    N = int((1+math.sqrt(1+4*tbl.shape[0]))/2)
    print(f'N={N}')
    cnt = 0
    for i in range(N-1):
        if N > 16 :
            if i < 2 or i > N-3:
                print(f'(%4d) ptbl[%7d:%7d]: (%4d, %4d), (%4d, %4d), ..., (%4d, %4d)'
                      % (i, cnt, cnt+N, tbl[cnt], tbl[cnt+1],
                         tbl[cnt+2], tbl[cnt+3],
                         tbl[cnt+N-2], tbl[cnt+N-1]))
        else :
            print(f'(%2d) ptbl[%2d:%2d]:' % (i, cnt, cnt+N), end='')
            for j in range(int(N/2)):
                print(f' (%2d,%2d)' % (tbl[cnt+2*j], tbl[cnt+2*j+1]), end='')
                if j < int(N/2)-1 : print(',', end='')
            print(']')
        cnt += N
    return

def mkTtbl(ptbl):
    ### 特殊回転のタイプ（= 0 or 1 or 2）は ptbl に基づいて決定
    ###   type: 0 --> normal rotation
    ###         1 --> incomplete rotation
    ###         2 --> no rotation
    N = int((1+math.sqrt(1+4*ptbl.shape[0]))/2)
    #print(f'N={N}')
    ranks = (1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048)
    rank_list = []
    for i in range(len(ranks)):
        if ranks[i] > N : break
        rank_list.append(ranks[i])
    R = len(rank_list)
    ranks = torch.tensor(rank_list, dtype=torch.int, device=ptbl.device, requires_grad=False)
    #print(R, ranks)
    tbl = torch.empty((R, N-1, int(N/2)), dtype=torch.int, device=device, requires_grad=False)
    #print(tbl.shape)
    for n in range(R):
        r = ranks[n] - 1
        cnt = [0] * N
        for step in range(0, N-1):
            #print(f' rank:{r+1}, step:{step}')
            for tid in range(0, int(N/2)):
                offset = step * N
                i = ptbl[offset + 2 * tid]
                j = ptbl[offset + 2 * tid + 1]
                if i <= r : cnt[j] += 1
                typ = 0
                if i > r : typ = 2
                else :
                    if r == cnt[j] - 1 : typ = 1
                #print(f'  N={N}, step={step}, tid={tid}, (i,j)=({i}, {j}),  type={typ}')
                #print(f'    cnt[0:{N-1}]:', end='')
                #for id in range(N) : print(f' {cnt[id]}', end='')
                #print()
                tbl[n][step][tid] = typ
    return ranks, tbl.view(-1)

def print_Ttbl(rank_list, tbl):
    #print(rank_list)
    #print(tbl.shape)
    R = len(rank_list)
    N = int((1+math.sqrt(1+8*tbl.shape[0]/R)/2))
    #print(f'R={R}, N={N}')
    for n in range(R):
        r = rank_list[n] - 1
        if n > 1 and r+1 < int(N/2) : continue
        print(f'rank: {r+1}')
        for step in range(0, N-1):
            if step > 3 and step < N-5 :
                if step == 4 : print('    ...')
                continue
            print(f'  step={step} :\t', end='')
            for tid in range(0, int(N/2)):
                if tid > 3 and tid < int(N/2)-4 :
                    if tid ==4 : print('  ...', end='')
                    continue
                print(f'  {tbl[int(n*N*(N-1)/2)+step*int(N/2)+tid]}', end='')
            print()
        print()
    return

def main(device, M):
    seed_everything(seed=0)
    dtype = torch.float64
    N = 2 ** M
    print(f'N={N}, device={device}, dtype={dtype}')

    ### ptbl の作成
    ptbl = mktbl(M, device)
    print('ptbl:', ptbl.shape, ptbl.dtype, ptbl.device)
    print_ptbl(ptbl)

    '''
    #### ranks, ttbl の作成
    ranks, ttbl = mkTtbl(ptbl)
    print('ranks:', ranks.shape, ranks.dtype, ranks.device)
    print(ranks)
    print('ttbl:', ttbl.shape, ttbl.dtype, ttbl.device)
    print_Ttbl(ranks, ttbl)
    '''

    ### ptbl, ttbl, ranks のファイルへの書き出し
    sow_dict = dict()
    sow_dict['ptbl'] = ptbl.to('cpu')
    #
    print('sow_dict:', type(sow_dict), 'len=', len(sow_dict))
    for k, v in sow_dict.items() :
        if torch.is_tensor(v) : print(' ', k, type(v), v.shape, v.dtype, v.device, v.requires_grad)
        else : print(' ', k, type(v), v)
    #
    torch.save(sow_dict, f'INIT/T%04d.dict' % (N))
    return

if __name__=='__main__':
    if len(sys.argv) != 3 :
        print(F'[USAGE] {sys.argv[0]} gpu M')
        exit()
    gpu = int(sys.argv[1])
    use_cuda = torch.cuda.is_available()
    if use_cuda:
        torch.cuda.set_device(gpu)
        device = torch.device(f'cuda:{gpu}')
    else: raise ValueError("CUDA is not available!!")
    M = int(sys.argv[2])
    main(device, M)
    exit()
